# 进程模型
![](../assets/nginx/chapter-2-1.png)

- nginx 即支持多线程方式（默认），也支持多进程方式运行
- master进程管理多个worker进程
    - 接受外界的信号，向各worker进程发送信号
    - 监控worker进程的运行状况
    - 当worker异常退出情况下，自动重启worker进程
- worker进程
    - 处理基本的网络事件，一个请求，只能在一个进程中处理
    - 多个worker进程之间是对等的，且互相独立，同等进程来自客户端的竞争。
    - 个数可以设置，一般设置与机器cpu核数一致

## 多worker方式处理请求
- worker内部异步非阻塞方式处理请求，避免上下文切换带来的cpu开销
- 事件模型 select/poll/epoll/kqueue，更加具体操作系统决定
- nginx为了更好的利用多核特性，提供了cpu亲缘性的绑定选项，我们可以将某一个进程绑定在某一个核上，这样就不会因为进程的切换带来cache的失效。

## 进程模型的好处
- 独立进程，不需要加索，编程也方便
- 相互独立，互相之间不会影响。进程的退出，服务不中断

## 定时器
由于epoll_wait等函数在调用的时候是可以设置一个超时时间的，nginx借助这个超时时间来实现定时器。
- nginx 维护一颗定时器的红黑树
- 每次epoll_wait前，从红黑树中拿到所有定时器的事件最小时间
- 计算出epoll_wait的超时时间后进入epoll_wait。
- 没有事件产生时，就没有中断，epoll_wait会超时，即定时器事件到了。
- nignx会检查所有的超时事件，将他们状态设置为超时，再去处理网络事件。

## 信号
以重启为例
- 老版本的 kill -HUP pid 
    master进程在接收到HUP信号后是怎么做的呢？首先master进程在接到信号后，会先重新加载配置文件，然后再启动新的worker进程，并向所有老的worker进程发送信号，告诉他们可以光荣退休了。新的worker在启动后，就开始接收新的请求，而老的worker在收到来自master的信号后，就不再接收新的请求，并且在当前进程中的所有未处理完的请求处理完成后，再退出。
- 0.8版本之后 nginx -s reload
    执行命令时，我们是启动一个新的nginx进程，而新的nginx进程在解析到reload参数后，就知道我们的目的是控制nginx来重新加载配置文件了，它会向master进程发送信号，然后接下来的动作，就和我们直接向master进程发送信号一样了。
## 参考
- [Nginx开发从入门到精通](http://tengine.taobao.org/book/)