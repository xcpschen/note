# InnoDB
InnoDB存储引擎，mysql5.5版本开始默认作为表存储引擎，是第一个完整支持ACID事务的MYSQL引擎：
- 行锁设计
- MVCC
- 外键
- 提供一致性非锁定读

## 体系架构

![](../../assets/mysql/innDB.jpg)
InnDB存储引擎有多个内存块，组成内存池，其主要工作：
- 维护所有进程/线程需要访问的多个内部数据结构
- 缓存磁盘上的数据，方便快速地读取，同时缓存对在磁盘文件修改之前的数据
- redo log

## 后台线程
- Master Thread
  - 核心线程
  - 负责缓冲池数据异步刷新到磁盘
  - 保证数据一致性，包括脏页的刷新，合并插入缓冲（INSERT BUFFED）
  - UNDO 页的回收
- IO Thread
  - 负责AIO请求的回调处理
  - 1.0版本之前有4个IO Thread:write,read,insert buffer 和log IO thread。
  - Linux 下 IO Thread数量不能进行调整，widnows平台可以通过`innodb_file_io_threads`来增大
  - 1.0.x之后，read thread 和write thread 分别增加到4个，使用`innodb_read_io_thread`和`innodb_write_io_threads`来设置
  - read thread ID总是小与 write thread ID
- Purge Thread
  - 回收分配的undo页
  - 1.1版本之前，purge 在 Master Thread中
  - 1.1版本开始，单独完成
  - 配置文件启用单独线程方式：
  ```
  [mysqld]
  innodb_purge_threads=1
  ```
  - 1.2开始，支持多个Purge Thread,进而加快undo页回收
- Page Cleaner Thread
  - 1.2之后引入，作用对脏页刷新操作，减轻Master Thread工作，以及用户查询线程的阻塞

## 内存
InnoDB存储引擎是基于磁盘存储，并将记录按页的方式进行管理，利用缓冲池技术提高数据库性能。
- 页FIX操作：从磁盘读取到页存储到缓冲池中，下次直接从缓冲池读取
- Checkpoint机制：数据库页修改操作，先修改缓冲池中页，然后以一定频率刷新到磁盘上

### 缓冲池
- 大小可通过参数`innodb_buffer_pool_size`来设置
- 缓冲数据页类型：
  - 索引页
  - 数据页
  - undo页
  - 插入缓冲（insert buffer）
  - 自适应哈希索引（adaptive hash index）
  - Innodb存储的锁信息（lock info）
  - 数据字典信息（data dictionary)
  - Flush 列表：脏页列表
- 1.0.x开始，运行多个缓冲池实例，每个页根据哈希平均分配到不同缓冲池中，减少并发带来的竞争
  - 通过`innodb_buffer_pool_instances`来配置实例多少
- Mysql5.6开始 通过`information_schema`下的表`INNODB_BUFFER_POOL_STATS`来观察缓冲状态
- 页大小默认`16KB`，1.0.x后支持压缩功能，可以压缩到1KB,2KB,4KB,8KB
- 脏页既存在LRU列表，也存在Flush列表
![](../../assets/mysql/memory.jpg)

### LRU List,Free List和Flush List
缓冲池通过LRU算法来管理：
- 最频繁使用的页在LRU表前端，最少的在尾端
- 当缓冲池不能存储新读取的页时，先释放LRU列表尾端的页
- InnoDB优化传统LRU算法
  - midpoint insertion strategy：
    - 增加`midpoint`位置，该位置之后的称为old列表，之前的称为new列表
    - 新增页放在midpoint位置
    - 配置参数`innodb_old_blocks_pct`，默认为LRU长度的`5/8`
  - 解决查询返回多个页，但页并非热点数据，容易移除真正热点数据：
    - 新增参数`innodb_old_blocks_time`，标示页读取到mid位置后需要等待多久才会被放在new列表
- 数据库刚启动是，LRU列表为空：
  - 页都在Free列表中，需要从缓冲池分页时：
    - 从Free列表中查找是否有可用的空闲页，有则将该页从Free列表删除，存储在LRU列表中，否则根据LRU算法，淘汰LRU列表末尾的页，将空间分给新的页。
  - 当页从old表加入到new时为`page made young`操作：
  - 当页因为innodb_old_blocks_time设置导致未能加入到new时称为`page not made young`
- 可以通过`SHOW ENGINE INNODB STATUS`来观察LRU和Free表的使用情况和状态
- 1.2版本开始，可以通过表`INNODB_BUFFER_PAGE_LRU`来观察每个LRU列表中每个页的具体信息
- 对页大小非16KB的，通过`unzip_LRU`列表管理：
  - 对存在表页大小不一致时：
    - 对不同压缩页大小进行分别管理
    - 通过伙伴算法进行内存分配（x 可选 2，4，8）：
      - 需要申请`xKB`大小页时
      - 检查`xKB`的unzip_LRU列表是否有空闲页
      - 有则直接使用
      - 没有则检查`2xKB`的unzip_LRU列表：
        - 得到足够的空闲页，则将页分成2个`xKB`页，存放在`xKB`的unzip_LRU列表
        - 不能则，申请`4xKB`的页，将页分1个`2xKB`的，2个`xKB`的，分别存储在对应的unzip_LRU列表
  - 通过`information_schema`的表`INNODB_BUFFER_PAGE_LRU`查看unzip_LRU列表的页
- 查看LRU中脏表语句`select TABLE_NAME,SPACE,PAGE_NUMBER,PAGE_TYPE FROM INNODB_BUFFER_PAGE_LRU WHERE OLDEST_MODIFICATION>0;` TABLE_NAME为NULL标示页属于系统表空间。
- 释放LRU上的脏页时，强制执行Checkpoint算法，刷新页信息到磁盘

Flush List管理
  - 管理页将刷新到磁盘，CHECKPOINT机制使用
  - 可以通过`SHOW ENGINE INNODB STATUS`来观察Flush List，`Modfied db pages xxx`代表脏页数量
### 重做日志缓冲-redo log buffer
InnoDB存储引擎先将重做日志信息存放到redo log buffer，然后按一定频率刷新到重做日志文件：
- `innodb_log_buffer_size`控制缓冲大小，默认：8MB；只需要保证每秒产生的事务量在这个大小之内即可
- 重做日志缓冲刷新到重做日志文件情况：
  - Master Thread 每秒将重做日志缓冲刷新到重做日志文件
  - 每个事务提交时将重做日志缓冲刷新到redo log 文件
  - 当重做日志缓冲剩余空间小于1/2时


### 额外的内存池
InnoDB存储引擎中，对内存管理时通过内存堆方式进行，对一些数据结构本身的内存分配时，需要从额外的内存池中申请；当该区域内存不够时，会从缓冲池申请，这些数据结构有：
- 缓冲池中的帧缓冲（frame buffer）
- 缓冲控制对象 （buffer control block）:
  - LRU
  - 锁
  - 。。。

## Checkpoint 技术
主要解决以下问题：
- 缩短数据库恢复时间
- 缓冲池不够时，将脏页刷新到磁盘
- 重做日志不可用时，刷新脏页

Checkpoint类型：
- Sharp Checkpoint
  - 发生在数据库关闭时，刷新所有脏页回磁盘
  - 参数`innodb_fast_shutdown=1`
- Fuzzy Checkpoint
  - InnoDB存储引擎内部使用,每次只刷新部分脏页，发送情况：
    - Master Thread Checkpoint
    - FLUSH_LRU_LIST Checkpoint
    - Async/Sync Flush Checkpoint
    - Dirty Page too much Checkpoint

### Write Ahead Log 策略
当事务提交时，先写重做日志，在修改页，达到持久性(D)的要求，避免数据丢失

### LSN策略
页使用LSN(Log Sequence Number)来标志版本，本身是8字节的数字。
通过`SHOW ENGINE INNODB STATUS`观察
