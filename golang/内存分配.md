
// The allocator's data structures are:
//
//	fixalloc: a free-list allocator for fixed-size off-heap objects,
//		used to manage storage used by the allocator.
//	mheap: the malloc heap, managed at page (8192-byte) granularity.
//	mspan: a run of in-use pages managed by the mheap.
//	mcentral: collects all spans of a given size class.
//	mcache: a per-P cache of mspans with free space.
//	mstats: allocation statistics.
## 分配结构说明
- fixalloc
- mheap
- mcentral
- mcache
- mstats

### 分配小对象流程
1. 大小向上取整匹配合适的size classes ，然后在当前的P mcache上的mspan查找对于的size class，
2. 扫描mspan的空闲bitmap,查找空闲的槽位，如果有则分配它，整个过程未上锁。
3. 如果没有空闲的槽位，从mcentral的合适大小类型的mspan列表里申请新的空间，一次申请多个，需要上锁
4. 如果mcentral上的mspan链表没有空闲的空间，则向mheap申请页
5. 如果mheap是空的或者没有合适的空虚page，则向OS申请一组新的page，至少1MB,申请过程会上锁
### 清扫mspan和释放对象过程
//	1. If the mspan is being swept in response to allocation, it
//	   is returned to the mcache to satisfy the allocation.
//
//	2. Otherwise, if the mspan still has allocated objects in it,
//	   it is placed on the mcentral free list for the mspan's size
//	   class.
//
//	3. Otherwise, if all objects in the mspan are free, the mspan's
//	   pages are returned to the mheap and the mspan is now dead.

通过mcache和mcentral 传递信息，直接使用mheap分配和释放大对象

如果mspan.needzero为false,则空闲的对象被插入到mspan时已经被零重制;如果为true,只有但被分配时重置。延迟重制的好处：
1. 栈桢分配能避免和零位点重合
2. 但程序在写内存时，临时性位置能被很好的展示
3. 0page不会被使用

## 虚拟内存结构
- 内存堆由一系列arenas组成
  - 64位时arenas大小为64MB，32位时4MB
  - 每个arenas开始地址对其其大小，其地址空间可以视为一系列arena桢
    - arenas.heapArena存储arenas的元信息,对外分配
      - heap bitmap(位图)记录arenas所有的字
      - span map 记录arenas所有的page
    - arenas 是个二维的map,映射则arena帧到*heapArena，或者其地址空间未被Go heap使用时的nil,
      - L1 为arena map
        - arenaL1Bits arena数量
            ```
            arenaL1Bits = 6 * (_64bit * sys.GoosWindows)
            ```
      - L2 为arenp maps
      - however, since arenas are large, on many architectures, the arena map consists of a single, large L2 map


// Number of orders that get caching. Order 0 is FixedStack
// and each successive order is twice as large.
// We want to cache 2KB, 4KB, 8KB, and 16KB stacks. Larger stacks
// will be allocated directly.
// Since FixedStack is different on different systems, we
// must vary NumStackOrders to keep the same maximum cached size.
//   OS               | FixedStack | NumStackOrders
//   -----------------+------------+---------------
//   linux/darwin/bsd | 2KB        | 4
//   windows/32       | 4KB        | 3
//   windows/64       | 8KB        | 2
//   plan9            | 4KB        | 3
_NumStackOrders = 4 - sys.PtrSize/4*sys.GoosWindows - 1*sys.GoosPlan9

heapAddrBits: 堆地址空间上位数
- amd64:addresses are sign-extended beyond heapAddrBits
- 其他：零扩展

最大分配大小：
- 64位时，1<<heapAddrBits 字节
- 32位，至少1<<32 字节



heapArenaBytes: heap 上arena的大小
初始化是heap分配一个arena

// heapArenaBitmapBytes is the size of each heap arena's bitmap.
```
heapArenaBitmapBytes = heapArenaBytes / (sys.PtrSize * 8 / 2)
```

heapAddrBits，heapArenaBytes,arena map maps （L1，L2） 大小之间的关系：
```
(1 << addr bits) = arena size * L1 entries * L2 entries
```
// Currently, we balance these as follows:
//
//       Platform  Addr bits  Arena size  L1 entries   L2 entries
// --------------  ---------  ----------  ----------  -----------
//       */64-bit         48        64MB           1    4M (32MB)
// windows/64-bit         48         4MB          64    1M  (8MB)
//       */32-bit         32         4MB           1  1024  (4KB)
//     */mips(le)         31         4MB           1   512  (2KB)


## 抽象OS 内存管理层
在runtime上，区域地址空间管理有四个状态：
- None
- Reserved
- Prepared
- Ready

# Ariticle
- [Thread-Caching Malloc](http://goog-perftools.sourceforge.net/doc/tcmalloc.html)
- [深入理解golang：内存分配原理](https://zhuanlan.zhihu.com/p/273363135)
- [详解Go语言的内存模型及堆的分配管理](https://zhuanlan.zhihu.com/p/76802887)
- [Go内存管理三部曲[1]- 内存分配](https://zhuanlan.zhihu.com/p/266496735)
- [Go 内存页管理 与 radix tree](https://zhuanlan.zhihu.com/p/263580536)
- [golang快速入门[5.3]-go语言是如何运行的-内存分配](https://www.zhihu.com/column/c_1212699838745346048)